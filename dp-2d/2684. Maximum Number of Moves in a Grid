Time O(m*n)
Space O(m)

class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        # move column-wise
        dp = [[0]*2 for _ in range(m)]

        for i in range(m):
            dp[i][0] = 1 # first column
        
        max_moves = 0
        for j in range(1,n):
            for i in range(m):
                if grid[i][j] > grid[i][j-1] and dp[i][0] > 0:
                    dp[i][1] = max(dp[i][1], dp[i][0]+1)
                if (i-1 >=0 and grid[i][j] > grid[i-1][j-1] and dp[i - 1][0] > 0):
                    dp[i][1] = max(dp[i][1], dp[i-1][0]+1)
                if (i+1 <m and grid[i][j] > grid[i+1][j-1] and dp[i + 1][0] > 0): #i+1< m comes first
                    dp[i][1] = max(dp[i][1],dp[i+1][0]+1)

                max_moves = max(max_moves, dp[i][1]-1)

            for i in range(m):
                dp[i][0] = dp[i][1]
                dp[i][1] = 0

        return max_moves

Moves always go to the next column,
This order is necessary because determining the value for cell (i, j) depends on the values of the cells in the previous column, namely (i - 1, j - 1), (i, j - 1), and (i + 1, j - 1).

we update dp[i][j] to be the maximum of its current value and one plus the value of the reachable cell:
dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1] + 1)

dp[i][0]  # previous column (j - 1)
dp[i][1]  # current column (j)

max_moves = max(max_move, dp[i][1]-1) why need to -1
Because dp is counting cells in the path, but the problem asks for moves.
That -1 is converting path length â†’ number of moves.


