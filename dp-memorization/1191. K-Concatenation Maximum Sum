# Time complexity: O(n)
# Space complexity: O(n) - arr+arr

class Solution:
    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        # some cases will be suffix of arr + (many full arr copies) + prefix of arr
        MOD = 10**9 + 7
        def kadane(nums):
            cur_sum = 0
            max_sum = 0

            for n in nums:
                cur_sum = max(cur_sum+n, 0) # empty string is allowed
                max_sum = max(cur_sum, max_sum)

            return max_sum

        
        if k == 1:
            return kadane(arr) % MOD

        best2 = kadane(arr+arr) # if the arr is [suffix of arr] + [prefix of arr]

        total = sum(arr)
        if total > 0:
            return (best2 + (k-2) * sum(arr)) % MOD # Adding full copies increases the sum → take all of them
        else: 
            return best2 % MOD # Adding full copies does nothing or hurts → avoid them.

# Brute Force: arr repeated k times
A direct approach would be: arr * k - O(nk)

2 passes captures every possible boundary-crossing shape. You don’t need 3 or 10 copies to know the best shape.
        


