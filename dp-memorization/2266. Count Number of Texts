# Time complexity: O(n)
# Space complexity: O(n)

class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        n = len(pressedKeys)
        dp = [0] * (n + 1)
        dp[0] = 1
        MOD = 10**9 +7
        
        for i in range(1, n+1):
            digit = pressedKeys[i-1]
            limit = 4 if digit in ('7', '9') else 3

            for k in range(1, limit+1):
                if i-k < 0:
                    break
                if pressedKeys[i-k] != digit:
                    break
                dp[i] = (dp[i] + dp[i-k]) % MOD

        return dp[n]

        
This matches the phone keypad description:
0 → no letters
1 → no letters
2–9 → letters
Since Alice never uses 0 or 1, Bob will never receive them. So the code never handles them

A single letter is made by pressing the same digit multiple times in a row:
- Digits 2,3,4,5,6,8 have 3 letters → you can use press groups of length 1..3
- Digits 7,9 have 4 letters → press groups of length 1..4
So Bob’s string must be split into chunks like:
"2", "22", "222" (valid for digit 2)
"7", "77", "777", "7777" (valid for digit 7)
and chunks cannot mix digits (like "23" is invalid).

Example: 
dp[2] = dp[1] + dp[0] = 1 + 1 = 2
Interpretations:
Copy code
(2)(2)   → "aa"
(22)     → "b"
i = 3 → "226"
dp[3] = dp[2] = 2
i = 4 → "2266"
"6" → dp[3]
"66" → dp[2]
dp[4] = 2 + 2 = 4
