Time Complexity: O(m*n)
Space complexity: O(n)

class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = grid[0][:] # first row

        for row in range(1, m):
            # find the smallest and second smallest
            min1 = min2 = float("inf")
            idx1 = -1
            for col in range(n):
                v = dp[col]
                if v < min1:
                    min2 = min1
                    min1 = v
                    idx1 = col
                elif v < min2:
                    min2 = v

            nxt = [0] * n
            for col in range(n):
                best_prev = min1 if col != idx1 else min2
                nxt[col] = grid[row][col] + best_prev

            dp = nxt

        return min(dp)


... blue cell ...
... red cell ... 

This red-cell minimum is valid for all green elements since it is not in the same column as the green elements.
However, it is invalid for the blue element since it is in the same column as the red element. Thus, for the blue element, we need to find the minimum excluding the red cell, which will be the second minimum of the next row.
Thus, for computing any element in memo, what ultimately matters is the minimum and second minimum of the next row. 

If it does not use min1 and min2, time complexity would be O(m*n*n), Scan all columns for each column

