# Time complexity: O(n)
# Space complexity: O(1)

class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        # Since this is a circular, so it uses total - min , Best subarray wraps around
        # Another case is best subarray does not wrap around
        total = nums[0]
        min_cur = nums[0]
        min_sum = nums[0]
        max_cur = nums[0]
        max_sum = nums[0]

        for n in nums[1:]:
            min_cur = min(min_cur+n, n)
            min_sum = min(min_sum, min_cur)

            max_cur = max(max_cur+n, n)
            max_sum = max(max_sum, max_cur)

            total += n
        
        # all negative
        if max_sum < 0:
            return max_sum

        return max(max_sum, total-min_sum)

# Brute Force: O(n**3) 
For a circular array of length n, naive brute force does:
- Choose a start index
- Choose a subarray length (or end index)
- Compute the sum of that subarray by looping over its elements
Thatâ€™s three loops.
