Time: O(n)
Space: O(1)

class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        # at most one deletion
        max_no_delete = arr[0]
        max_one_delete = arr[0]
        result = arr[0]

        for i in range(1,len(arr)):
            prev_no_delete = max_no_delete
            max_no_delete = max(max_no_delete+arr[i], arr[i])
            # One-deletion logic:
            # 1. Use existing deletion and keep current element.
            # 2. Skip current element (use prev_no_delete).
            max_one_delete = max(max_one_delete+arr[i], prev_no_delete)

            result = max(result, max_no_delete, max_one_delete)

        return result
        
Why it can’t “go to prev_no_delete again” and delete twice
To delete twice, you’d need a transition that deletes an element while already in the one-deletion-used state.
